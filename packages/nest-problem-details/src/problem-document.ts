import { HttpException, HttpStatus, Logger } from '@nestjs/common';
import _ from 'lodash';
import { JsonObject } from 'type-fest';
import { defaultHttpErrors } from './constants';
import { ProblemDocumentDto, ProblemDocumentExtensionsDto } from './dtos';
import { ErrorDetail } from './interfaces';
import { ProblemDetail } from './interfaces/problem-detail.type';

const Terms = {
  unspecified_error: 'An error occurred'
};

/**
 * property type (required)
 * A URI reference [RFC3986] that identifies the problem type.
 * This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type
 * (e.g., using HTML [W3C.REC-html5-20141028]).
 * When this member is not present, its value is assumed to be "about:blank".
 *
 * property title (required):
 * A short, human-readable summary of the problem type.
 * It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization
 * (e.g., using proactive content negotiation; see[RFC7231], Section 3.4).
 *
 * property status (required):
 * The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
 *
 * property detail (options):
 * A human-readable explanation specific to this occurrence of the problem.
 *
 * property instance (options):
 * A URI reference that identifies the specific occurrence of the problem.
 * It may or may not yield further information if dereferenced.
 *
 * property internal (optionl):
 * An optional custom object holding any internal ifnormation which will only be returned in development and test environment
 *
 */

export class ProblemDocument {
  private readonly logger = new Logger(ProblemDocument.name);

  protected constructor(
    private readonly problemDocument: ProblemDocumentDto,
    private readonly extensions?: ProblemDocumentExtensionsDto
  ) {}

  /**
   * create an instance of ProblemDocument providing all required information
   * @param objectOrMessage
   * @param extensions
   * @returns
   */
  static create(
    problemDocument: ProblemDocumentDto,
    extensions?: ProblemDocumentExtensionsDto
  ): ProblemDocument {
    return new ProblemDocument({ ...problemDocument }, extensions);
  }

  /**
   * create an instance of ProblemDocument based upon an Error or HttpException
   * @param exception
   */
  static from(exception: string): ProblemDocument;
  static from(exception: HttpException): ProblemDocument;
  static from(exception: Error): ProblemDocument;
  static from(exception: ProblemDetail): ProblemDocument;
  static from(
    exception: ProblemDetail | Error | HttpException | string
  ): ProblemDocument {
    if (exception instanceof HttpException) {
      return ProblemDocument.fromHttpException(exception);
    }

    if (exception instanceof Error) {
      return ProblemDocument.fromError(exception);
    }

    if (typeof exception === 'string') {
      return ProblemDocument.fromError(new Error(exception));
    }

    if (exception.type && exception.title && exception.status) {
      return new ProblemDocument({ ...exception });
    }

    throw new TypeError(
      'Failed to create a ProblemDocument from provided paramters'
    );
  }

  /**
   * create an instance of ProblemDocument from an Error
   * @param exception
   * @returns
   */
  static fromError(exception: Error): ProblemDocument {
    const status = HttpStatus.INTERNAL_SERVER_ERROR;
    const type = defaultHttpErrors[status];
    const title = _.startCase(type);
    const detail = exception.message;
    const extensions: ProblemDocumentExtensionsDto = {
      internal: { stack: exception.stack }
    };
    return new ProblemDocument({ type, status, title, detail }, extensions);
  }

  /**
   * create an instance of ProblemDocument from a nest HttpException
   * @param exception
   * @returns
   */
  static fromHttpException(exception: HttpException): ProblemDocument {
    const status = exception.getStatus();

    const errorResponse = exception.getResponse() as string | JsonObject;

    // If errorResponse is an instance of ProblemDocument clone it and add stack information
    if (errorResponse instanceof ProblemDocument) {
      const internal = { stack: exception.stack };
      return errorResponse.duplicate({ internal });
    }

    // If errorResposnse is a string we simply return a basic ProblemDocument
    if (typeof errorResponse === 'string') {
      const type = defaultHttpErrors[status];
      const title = _.startCase(type);
      const detail = errorResponse;
      return new ProblemDocument({ type, status, title, detail });
    }

    const response = { ...errorResponse };

    delete response.statusCode;

    const type = defaultHttpErrors[status];
    let title = _.startCase(type);
    let detail: string | undefined;
    let extensions: ProblemDocumentExtensionsDto = {};

    if (_.isString(response.message) && _.isString(response.error)) {
      title = response.error;
      detail = response.message;

      delete response.error;
      delete response.message;
    } else if (_.isString(response.message) && _.isEmpty(response.error)) {
      title = response.message;
      detail = Terms.unspecified_error;

      delete response.message;
    } else if (_.isString(response.message)) {
      detail = response.message;
      delete response.message;
    }

    const internal = {
      ...(response.internal as JsonObject),
      stack: exception.stack
    };
    extensions = { ...response, internal };

    return new ProblemDocument({ type, status, title, detail }, extensions);
  }

  /**
   * Priode the representation og the ProblemDocument as Problem Details response
   * @returns
   */
  createResponse(): ProblemDetail {
    const type =
      this.problemDocument.type ||
      defaultHttpErrors[this.problemDocument.status];
    const title = this.problemDocument.title || _.startCase(type);

    return { ...this.extensions, ...this.problemDocument, type, title };
  }

  /**
   * A helper function for creating a duplicate with an option for adding/overwriting extensiosn properties
   * @param extensions
   * @returns
   */
  duplicate(extensions?: ProblemDocumentExtensionsDto): ProblemDocument {
    return new ProblemDocument(this.problemDocument, {
      ...this.extensions,
      ...extensions
    });
  }

  /**
   * create an error log entry from this ProblemDocument
   * @returns this for chaining
   */
  logError(): this {
    const response = this.createResponse();
    const msg = `${response.detail} (${response.title})`;
    this.logger.error({ msg, response });
    return this;
  }

  getError(): ErrorDetail[] | undefined {
    return this.problemDocument.errors;
  }

  getInternal(): JsonObject | undefined {
    return this.problemDocument.internal;
  }
}
